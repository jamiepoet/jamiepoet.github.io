<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>代码书生</title>
  <subtitle>碧海琼涛连天涯，快意心波逐浪花</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://jamiepoet.github.io/"/>
  <updated>2016-08-03T09:36:11.000Z</updated>
  <id>http://jamiepoet.github.io/</id>
  
  <author>
    <name>代码书生</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>基于XMPP实现即时通讯（五、Demo）</title>
    <link href="http://jamiepoet.github.io/2016/08/02/%E5%9F%BA%E4%BA%8EXMPP%E5%AE%9E%E7%8E%B0%E5%8D%B3%E6%97%B6%E9%80%9A%E8%AE%AF%EF%BC%88%E4%BA%94%E3%80%81Demo%EF%BC%89/"/>
    <id>http://jamiepoet.github.io/2016/08/02/基于XMPP实现即时通讯（五、Demo）/</id>
    <published>2016-08-02T09:30:56.000Z</published>
    <updated>2016-08-03T09:36:11.000Z</updated>
    
    <content type="html">&lt;p&gt;Demo地址： &lt;a href=&quot;https://github.com/Jamie-Ling-iOS/LG-XMPPDemo&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/Jamie-Ling-iOS/LG-XMPPDemo&lt;/a&gt;&lt;br&gt;欢迎大家关注回复或加我QQ:2726786161，一起学习，探讨。&lt;/p&gt;
&lt;p&gt;作者 [@代码书生][1]&lt;br&gt;2016 年 08月 02日    &lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;Demo地址： &lt;a href=&quot;https://github.com/Jamie-Ling-iOS/LG-XMPPDemo&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/Jamie-Ling-iOS/LG-XMPPD
    
    </summary>
    
      <category term="即时通讯（IM）" scheme="http://jamiepoet.github.io/categories/%E5%8D%B3%E6%97%B6%E9%80%9A%E8%AE%AF%EF%BC%88IM%EF%BC%89/"/>
    
    
      <category term="XMPP" scheme="http://jamiepoet.github.io/tags/XMPP/"/>
    
      <category term="IM" scheme="http://jamiepoet.github.io/tags/IM/"/>
    
      <category term="iOS" scheme="http://jamiepoet.github.io/tags/iOS/"/>
    
      <category term="Mac" scheme="http://jamiepoet.github.io/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>基于XMPP实现即时通讯（四、聊天记录、聊天室）</title>
    <link href="http://jamiepoet.github.io/2016/08/02/%E5%9F%BA%E4%BA%8EXMPP%E5%AE%9E%E7%8E%B0%E5%8D%B3%E6%97%B6%E9%80%9A%E8%AE%AF%EF%BC%88%E5%9B%9B%E3%80%81%E8%81%8A%E5%A4%A9%E8%AE%B0%E5%BD%95%E3%80%81%E8%81%8A%E5%A4%A9%E5%AE%A4%EF%BC%89/"/>
    <id>http://jamiepoet.github.io/2016/08/02/基于XMPP实现即时通讯（四、聊天记录、聊天室）/</id>
    <published>2016-08-02T06:01:25.000Z</published>
    <updated>2016-08-03T08:39:13.000Z</updated>
    
    <content type="html">&lt;p&gt;本章来学习XMPP最后两个大的应用知识点：聊天记录和聊天室。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;一、聊天记录&quot;&gt;&lt;a href=&quot;#一、聊天记录&quot; class=&quot;headerlink&quot; title=&quot;一、聊天记录&quot;&gt;&lt;/a&gt;一、聊天记录&lt;/h2&gt;&lt;p&gt;XMPP默认通过coredata存储聊天记录，先初始化并进行激活&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//消息相关
var _xmppMessageArchinving: XMPPMessageArchiving!
var _xmppMessageStorage: XMPPMessageArchivingCoreDataStorage!
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在activeXMPPModules方法中激活模块：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//消息相关
_xmppMessageStorage = XMPPMessageArchivingCoreDataStorage()
_xmppMessageArchinving = XMPPMessageArchiving(messageArchivingStorage: _xmppMessageStorage)
_xmppMessageArchinving.clientSideMessageArchivingOnly = true
//激活&amp;amp;添加代理
_xmppMessageArchinving.activate(_xmppStream)
_xmppMessageArchinving.addDelegate(self, delegateQueue: dispatch_get_main_queue())
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;功能实现，可以根据聊天界面下拉刷新的具体逻辑来实现一次获取多少条，或者是消息管理中心的全部记录，这里一次性获取全部聊天记录，不考虑数据量超大的情况：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  /**
     获取聊天记录

 - parameter userID:              如果为空，就是本地所有好友全部的聊天记录，这里friendid也可以为房间id,因为我们的房间信息发送走的也是正常聊天的_xmppMessageStorage存储
 - parameter getMessageListBlock: 回调
 */
func getMessageList(friendId: String?, getMessageListBlock: LGXMPP_GetMessageListBlock) {

    //如果是房间聊天，也可以从_xmppRoomStorage中获取数据库（xmppRoomStorage可以初始化为内存中的群消息对象，或者单独为群创建的coredata）
    let context = _xmppMessageStorage.mainThreadManagedObjectContext
    let entity = NSEntityDescription.entityForName(&amp;quot;XMPPMessageArchiving_Message_CoreDataObject&amp;quot;, inManagedObjectContext: context)

    let request = NSFetchRequest()
    request.entity = entity

    //全部查询出来
    //request.fetchLimit = 50         //一次最多查询50

    if friendId != nil{
        // 过滤内容，只找我与正要聊天的好友的聊天记录,注意：数据库内为小写
        let friendJidString = self.getChatJidString(friendId!)
        let predicate = NSPredicate(format: &amp;quot;bareJidStr = %@&amp;quot;, friendJidString)
        request.predicate = predicate
    }

    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)) {

        var results: [XMPPMessageArchiving_Message_CoreDataObject]?
        do {
            try results = context.executeFetchRequest(request) as? [XMPPMessageArchiving_Message_CoreDataObject]
        } catch let error as NSError {
            dispatch_async(dispatch_get_main_queue(), {
                return getMessageListBlock(messageList: nil, faildMsg: error.description)
            })
        }
        if (results != nil) &amp;amp;&amp;amp; (results?.count != 0){
            var array = [XHMessage]()
            for object in results! {

                let oldMessage = self.getXHMessageFromXMPPMessage(object.message, messageSender: object.bareJidStr, isUserSendMessage: object.outgoing.intValue == 1 ? true : false, isHistory: true)

                if oldMessage.messageMediaType == XHBubbleMessageMediaType.Voice &amp;amp;&amp;amp; oldMessage.voicePath == nil{
                    //语音没有从本地读到
                    //尝试在子线程去下载，下次拉记录时可以刷新出来，这次不再显示----也可以自己控制异步加载显示
                    LGTXCloudManager.shared.downloadFile(oldMessage.voiceUrl, sign: kTXCloud_File_Secret_ManyTime, sucessResult: nil, faildMsg: nil)
                    continue
                }

                oldMessage.avatar = UIImage(named: &amp;quot;_App_Icons&amp;quot;)
                oldMessage.avatarUrl = &amp;quot;http://lorempixel.com/400/200/&amp;quot;
                array.append(oldMessage)
            }
            dispatch_async(dispatch_get_main_queue(), {
                return getMessageListBlock(messageList: array, faildMsg: nil)
            })
        }
        dispatch_async(dispatch_get_main_queue(), {
            return getMessageListBlock(messageList: nil, faildMsg: nil)
        })
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;二、聊天室&quot;&gt;&lt;a href=&quot;#二、聊天室&quot; class=&quot;headerlink&quot; title=&quot;二、聊天室&quot;&gt;&lt;/a&gt;二、聊天室&lt;/h2&gt;&lt;p&gt;聊天室也就是群聊，不过有一些业务权限上的区别，XMPP里面的聊天室是比较传统的聊天室业务，权限有：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;拥有者 owner
管理员：admin 
成员：member  
黑名单：outcast  
游客：none（默认被邀请者为游客）
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;创建房间的人，默认就会成为owner，当owner邀请新用户加入房间时，如果不指定角色，默认为游客&lt;br&gt;房间拥有者可以改变房间配置、授予用户所有权和管理权限以及毁掉此房间。房间管理员可以禁止或授予用户权限和新的管理员权限。房间成员仅能允许用户加入房间（如果该房间配置为仅对成员开放）。同时房间被排除者是已禁止进入该房间的用户。XMPP中所说的主持人角色包括owner和admin，详见&lt;a href=&quot;http://xmpp.org/extensions/xep-0045.html#associations&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://xmpp.org/extensions/xep-0045.html#associations&lt;/a&gt;&lt;br&gt;以上角色通过邀请时指定Affiliation来实现，如设置被邀请者的Affiliation为member表示给此被邀请用户成员角色&lt;br&gt;注意：只有owner和admin才有查询房间所有角色名单的权限，所以根据需求这里我们给被邀请者admin权限, 所有人都是主持人，但只有拥有者才可以销毁房间&lt;/p&gt;
&lt;p&gt;为了使Demo简单明了，我们的业务逻辑是只允许用户在一个聊天室内聊天，要进入一个新的聊天室必须先离开原房间或销毁原房间。&lt;/p&gt;
&lt;h3 id=&quot;1-初始化&quot;&gt;&lt;a href=&quot;#1-初始化&quot; class=&quot;headerlink&quot; title=&quot;1. 初始化&quot;&gt;&lt;/a&gt;1. 初始化&lt;/h3&gt;&lt;p&gt;先初始化并进行激活：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var _xmppRoom: XMPPRoom?                                    //自己当前创建的聊天室
var _xmppRoomJid: XMPPJID?                                  //房间jid
var _xmppRoomOwnerMe = false                                //此房间是否是我创建的
var _xmppRoomStorage = XMPPRoomMemoryStorage()              //聊天室信息存储，只是放到内存中，也可根据业务情况用coredata方式的对象存储,如XMPPRoomCoreDataStorage
var _createChatRoomBlock: LGXMPP_CreateChatRoomBlock?       //创建房间回调
var _getChatRoomModeratorsBlock: LGXMPP_GetChatRoomModeratorsBlock? //获取房间主持人列表
var _xmppRoomCreateSuccess = false                          //房间创建成功
var _inChatRoom = false                                     //是否已经在聊天室内，因为本demo要确保同一时间只能在一个聊天室聊天

var _xmppMuc: XMPPMUC!                                      //房间邀请等数据对象
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在activeXMPPModules方法中激活模块：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//聊天室相关
_xmppMuc = XMPPMUC()
_xmppStream.registerModule(_xmppMuc)
_xmppMuc.activate(_xmppStream)
_xmppMuc.addDelegate(self, delegateQueue: dispatch_get_main_queue())
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;声明房间对应的host,注意必须带”conference”（可以在Openfire控制台群组聊天中查看到对应域名）:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let vHostRoom = &amp;quot;conference.JamieiMac.local&amp;quot;  
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;2-创建、加入、邀请加入聊天室&quot;&gt;&lt;a href=&quot;#2-创建、加入、邀请加入聊天室&quot; class=&quot;headerlink&quot; title=&quot;2. 创建、加入、邀请加入聊天室&quot;&gt;&lt;/a&gt;2. 创建、加入、邀请加入聊天室&lt;/h3&gt;&lt;p&gt;注意：经过调试，创建房间方法调用后需要立即调用让自己肯定加入房间的方法，这样才能收到房间建立成功的回调，可能的原因是：默认自己肯定要加入房间，同时要加入房间才能收到房间建立成功的回调。&lt;br&gt;同时：当自己加入别人创建的房间时，也不会回调房间创建成功的方法，只会回调加入房间成功&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; /**
     创建聊天室，并且直接加入此聊天室
 - parameter roomID:              聊天室ID，可以自己创建，也可根据需求向服务器申请
 - parameter ownerMe:             是否是自己创建的房间，他人邀请我加入房间时，我也要生成对应的房间对象
 - parameter createChatRoomBlock: 创建完房间的回调
 */
func createChatRoom(roomID: String, ownerMe: Bool, createChatRoomBlock: LGXMPP_CreateChatRoomBlock) {

    let roomJid = XMPPJID.jidWithString(&amp;quot;\(roomID)@\(vHostRoom)&amp;quot;)

    _xmppRoomOwnerMe = ownerMe
    if _xmppRoom != nil &amp;amp;&amp;amp; _xmppRoom?.roomJID.user == roomJid.user &amp;amp;&amp;amp; _xmppRoomCreateSuccess == true {
        //已经创建过了的房间
        createChatRoomBlock(isSuccess: true, faildMsg: nil)
        return
    }

    _xmppRoomCreateSuccess = false
    _createChatRoomBlock = nil
    _createChatRoomBlock = createChatRoomBlock

    _xmppRoom = XMPPRoom(roomStorage: _xmppRoomStorage, jid: roomJid, dispatchQueue: dispatch_get_main_queue())

    _xmppRoom?.activate(_xmppStream)
    _xmppRoom?.addDelegate(self, delegateQueue: dispatch_get_main_queue())

    //默认自己肯定要加入房间，同时要加入房间才能收到房间建立成功的回调
    self.joinNowChatRoom(_userId!)
}

/**
 加入聊天室
 - parameter nickName: 聊天室内的个人昵称
 */
func joinNowChatRoom(nickName: String) {
    _xmppRoom!.joinRoomUsingNickname(nickName, history: nil)
}

  /**
 邀请新人进入聊天室
 - parameter friendId: 好友ID（通常只能邀请自己的好友）
 */
func inviteUserToChatRoom(friendId: String) {
    let friendJidString = self.getChatJidString(friendId)
    let friendJID = XMPPJID.jidWithString(friendJidString)
    _xmppRoom!.inviteUser(friendJID, withMessage: &amp;quot;\(_userId!)邀请您加入群&amp;quot;)
    //只有owner和admin才有查询房间所有角色名单的权限，所以根据需求这里我们给被邀请者admin权限, 这样所有人都是主持人，但只有拥有者才可以销毁房间
    _xmppRoom!.editRoomPrivileges([XMPPRoom.itemWithAffiliation(&amp;quot;admin&amp;quot;, jid: friendJID)])
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;对应回调：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func xmppRoomDidCreate(sender: XMPPRoom!) {

       DPrintln(&amp;quot;房间创建成功 \(sender)&amp;quot;)

       //设置房间默认配置属性
       _xmppRoom!.configureRoomUsingOptions(nil)


       _xmppRoomCreateSuccess = true
       if _createChatRoomBlock != nil{
           _createChatRoomBlock!(isSuccess: true, faildMsg: nil)
           _createChatRoomBlock = nil
       }
   }

   func xmppRoomDidJoin(sender: XMPPRoom!) {
       DPrintln(&amp;quot;加入房间成功\(sender)&amp;quot;)

       _inChatRoom = true

       //当加入已创建聊天室时，不会回调xmppRoomDidCreate，所以在此进行回调处理
       _xmppRoomCreateSuccess = true
       if _createChatRoomBlock != nil{
           _createChatRoomBlock!(isSuccess: true, faildMsg: nil)
           _createChatRoomBlock = nil
       }
   }
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;3-查询聊天室相关信息&quot;&gt;&lt;a href=&quot;#3-查询聊天室相关信息&quot; class=&quot;headerlink&quot; title=&quot;3. 查询聊天室相关信息&quot;&gt;&lt;/a&gt;3. 查询聊天室相关信息&lt;/h3&gt;&lt;p&gt;可以根据需求在加入聊天室成功后调用以下方法，但要注意，刚加入时去查询有可能会返回来空数组，这时可以尝试延时几秒去请求查询&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;_xmppRoom.fetchConfigurationForm    //查询聊天室配置
_xmppRoom.fetchBanList              //查询聊天室黑名单角色清单
_xmppRoom.fetchMembersList          //查询聊天室成员角色清单
_xmppRoom.fetchModeratorsList       //查询聊天室主持人角色清单
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;对应以下回调：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// MARK:  --------------------------------  聊天室回调 -- 信息查询  -------------------------------
func xmppRoom(sender: XMPPRoom!, didFetchBanList items: [AnyObject]!) {
    DPrintln(&amp;quot;收到本群/房间 禁止人员 名单 \(items)&amp;quot;)
}

func xmppRoom(sender: XMPPRoom!, didFetchMembersList items: [AnyObject]!) {
    DPrintln(&amp;quot;收到本群/房间 所有成员角色名单 \(items)&amp;quot;)

}

func xmppRoom(sender: XMPPRoom!, didFetchConfigurationForm configForm: DDXMLElement!) {
    DPrintln(&amp;quot;获取到了聊天室配置属性\(configForm)&amp;quot;)
}

func xmppRoom(sender: XMPPRoom!, didFetchModeratorsList items: [AnyObject]!) {
    DPrintln(&amp;quot;收到本群/房间 主持人员/管理人员  名单 \(items)&amp;quot;)
}

func xmppRoom(sender: XMPPRoom!, didNotFetchBanList iqError: XMPPIQ!) {
    DPrintln(&amp;quot;查询失败，无法收到本群/房间 禁止人员 名单&amp;quot;)
}

func xmppRoom(sender: XMPPRoom!, didNotFetchMembersList iqError: XMPPIQ!) {
    DPrintln(&amp;quot;查询失败，无法收到本群/房间 所有人员 名单&amp;quot;)
}

func xmppRoom(sender: XMPPRoom!, didNotFetchModeratorsList iqError: XMPPIQ!) {
    DPrintln(&amp;quot;查询失败，无法收到本群/房间 主持人员/管理人员  名单&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;还有其它设置聊天室配置是否成功等相关回调，可以根据需求添加。&lt;br&gt;加入聊天室成功后，也可以从本地数据库中查询聊天室人员信息，本Demo采用的是此方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 获取群内所有人的userid清单（即jid的user）
 */
func getRoomAllOccupantsList() -&amp;gt; [String]? {
    if _xmppRoomStorage.occupants() == nil{
        return nil
    }
    var idArray = [String]()
    for occupantStorageObject in _xmppRoomStorage.occupants(){
        let jidString = occupantStorageObject.realJID().user
        idArray.append(jidString)
    }
    return idArray
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;4-收到邀请、离开、销毁聊天室&quot;&gt;&lt;a href=&quot;#4-收到邀请、离开、销毁聊天室&quot; class=&quot;headerlink&quot; title=&quot;4. 收到邀请、离开、销毁聊天室&quot;&gt;&lt;/a&gt;4. 收到邀请、离开、销毁聊天室&lt;/h3&gt;&lt;p&gt;聊天室邀请来自XMPPMUCDelegate的回调：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func xmppMUC(sender: XMPPMUC!, roomJID: XMPPJID!, didReceiveInvitation message: XMPPMessage!) {
        DPrintln(&amp;quot;收到聊天室邀请&amp;quot;)

        let roomName = message.attributeForName(&amp;quot;from&amp;quot;).stringValue()
        let x = message.elementForName(&amp;quot;x&amp;quot;) as DDXMLElement
        let invite = x.elementForName(&amp;quot;invite&amp;quot;)
        let fromUser = invite.attributeForName(&amp;quot;from&amp;quot;).stringValue()
        let reason = invite.elementForName(&amp;quot;reason&amp;quot;).stringValue()

        _xmppRoomJid = roomJID  //记录要进入的房间id
        let alert = UIAlertView(title: &amp;quot;来自\(fromUser)的聊天室邀请&amp;quot;, message: &amp;quot;\(reason)，是否加入\(roomName)?&amp;quot;, delegate: self, cancelButtonTitle: &amp;quot;拒绝&amp;quot;, otherButtonTitles: &amp;quot;加入&amp;quot;)
        alert.tag = vJoinGroupAlertTag
        alert.show()
 }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后在&lt;a href=&quot;http://jamiepoet.github.io/2016/07/29/%E5%9F%BA%E4%BA%8EXMPP%E5%AE%9E%E7%8E%B0%E5%8D%B3%E6%97%B6%E9%80%9A%E8%AE%AF%EF%BC%88%E4%B8%89%E3%80%81%E5%A2%9E%E5%88%A0%E5%A5%BD%E5%8F%8B%E3%80%81%E5%A5%BD%E5%8F%8B%E5%88%97%E8%A1%A8%E3%80%81%E5%8F%91%E9%80%81%E5%90%84%E7%A7%8D%E6%B6%88%E6%81%AF%EF%BC%89/#3-%E5%A2%9E%E5%88%A0%E5%A5%BD%E5%8F%8B%E7%9A%84%E7%9B%B8%E5%85%B3%E5%9B%9E%E8%B0%83&quot;&gt;UIAlertView delegate&lt;/a&gt;中添加以下内容&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;...
 else if alertView.tag == vJoinGroupAlertTag{
            if buttonIndex == 1{
                DPrintln(&amp;quot;同意加入群&amp;quot;)
                if _inChatRoom == true &amp;amp;&amp;amp; _xmppRoom != nil{
                    //或者此处让用户选择直接退出当前房间的逻辑也可
                    Tools.shared.showAlertViewAndDismissDefault(&amp;quot;请先退出当前房间&amp;quot;, message: &amp;quot;同一时刻你只能加入一个房间&amp;quot;)
                    return
                }

                weak var weakSelf = self
                //创建此群对象及相关代理
                self.createChatRoom(_xmppRoomJid!.user, ownerMe: false, createChatRoomBlock: { (isSuccess, faildMsg) in
                    dispatch_async(dispatch_get_main_queue(), {

                        if isSuccess{
                           //以通知的方式将房间完整jid传给对应的界面去跳转或刷新UI
                          //需要群人员清单时通过上面的getRoomAllOccupantsList()方法获取
                           NSNotificationCenter.defaultCenter().postNotificationName(&amp;quot;joinChatRoom&amp;quot;, object: weakSelf!._xmppRoomJid!.bareJID().full(), userInfo: nil)
                        }
                    })
                })
            }else{
                DPrintln(&amp;quot;&amp;quot;)
            }
        }
    ...
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;离开、销毁聊天室：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; /**
     离开当前房间
     */
func levaRoom() {

    if _xmppRoom != nil{
        //如果是自己创建的房间，直接销毁此房间
        if _xmppRoomOwnerMe{
            _xmppRoom?.destroyRoom()

        }
        else{
            _xmppRoom!.leaveRoom()
        }
        _inChatRoom = false
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;对应相关的回调：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func xmppRoomDidLeave(sender: XMPPRoom!) {
    DPrintln(&amp;quot;退出房间成功\(sender)&amp;quot;)
    _xmppRoom = nil
}

func xmppRoomDidDestroy(sender: XMPPRoom!) {
    DPrintln(&amp;quot;房间已经销毁\(sender)&amp;quot;)
    _xmppRoom = nil
}

func xmppRoom(sender: XMPPRoom!, occupantDidJoin occupantJID: XMPPJID!, withPresence presence: XMPPPresence!) {
    DPrintln(&amp;quot;有新人加入房间\(occupantJID)&amp;quot;)
}

func xmppRoom(sender: XMPPRoom!, occupantDidLeave occupantJID: XMPPJID!, withPresence presence: XMPPPresence!) {
    DPrintln(&amp;quot;有新人离开房间\(occupantJID)&amp;quot;)
}

func xmppRoom(sender: XMPPRoom!, occupantDidUpdate occupantJID: XMPPJID!, withPresence presence: XMPPPresence!) {
    DPrintln(&amp;quot;房间有人更新了个人状态\(occupantJID)&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;5-聊天室消息&quot;&gt;&lt;a href=&quot;#5-聊天室消息&quot; class=&quot;headerlink&quot; title=&quot;5. 聊天室消息&quot;&gt;&lt;/a&gt;5. 聊天室消息&lt;/h3&gt;&lt;p&gt;聊天室发送消息和 &lt;a href=&quot;http://jamiepoet.github.io/2016/07/29/%E5%9F%BA%E4%BA%8EXMPP%E5%AE%9E%E7%8E%B0%E5%8D%B3%E6%97%B6%E9%80%9A%E8%AE%AF%EF%BC%88%E4%B8%89%E3%80%81%E5%A2%9E%E5%88%A0%E5%A5%BD%E5%8F%8B%E3%80%81%E5%A5%BD%E5%8F%8B%E5%88%97%E8%A1%A8%E3%80%81%E5%8F%91%E9%80%81%E5%90%84%E7%A7%8D%E6%B6%88%E6%81%AF%EF%BC%89/#1-%E5%8F%91%E9%80%81&quot;&gt;1对1聊天发送消息&lt;/a&gt; 调用方法相同，只是发出的Jid为房间id&lt;br&gt;聊天室消息接收如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// MARK:  --------------------------------  聊天室回调 -- 收到信息  -------------------------------
func xmppRoom(sender: XMPPRoom!, didReceiveMessage message: XMPPMessage!, fromOccupant occupantJID: XMPPJID!) {
    DPrintln(&amp;quot;收到信息, 来自房间 \(sender), 内容：\(message) ）&amp;quot;)

    let messageString = message.stringValue()

    //群聊时要将自己的信息排除，因为发出去的信息还会回传给自己
    let fromID = occupantJID.full().lastPathComponent
    if !messageString.isEmpty &amp;amp;&amp;amp; fromID.lowercaseString != _userId?.lowercaseString{

        let newMessage = self.getXHMessageFromXMPPMessage(message, messageSender: message.from().full(), isUserSendMessage: false, isHistory: false)
        //同1对1接收消息一样，走同样的通知
        NSNotificationCenter.defaultCenter().postNotificationName(kXMPPNewMessage, object: newMessage, userInfo: nil)
    }
    else{
        DPrintln(&amp;quot;收到其它类型消息/非正常消息/回执等&amp;quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;聊天室消息记录和1对1获取消息记录一样，查询的Jid为房间iD即可，也可能通过_xmppRoomStorage去从内存或单独的群数据库中读取。&lt;/p&gt;
&lt;p&gt;好了，整个XMPP的内容都学习了一次，剩下注册、查询房间列表等小的功能点，大家自己实现哈，有问题也可以找我交流学习哈，下章会将Demo给出。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;作者 &lt;a href=&quot;http://jamiepoet.github.io&quot;&gt;@代码书生&lt;/a&gt;&lt;br&gt;2016 年 08月 02日    &lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;本章来学习XMPP最后两个大的应用知识点：聊天记录和聊天室。&lt;br&gt;
    
    </summary>
    
      <category term="即时通讯（IM）" scheme="http://jamiepoet.github.io/categories/%E5%8D%B3%E6%97%B6%E9%80%9A%E8%AE%AF%EF%BC%88IM%EF%BC%89/"/>
    
    
      <category term="XMPP" scheme="http://jamiepoet.github.io/tags/XMPP/"/>
    
      <category term="IM" scheme="http://jamiepoet.github.io/tags/IM/"/>
    
      <category term="iOS" scheme="http://jamiepoet.github.io/tags/iOS/"/>
    
      <category term="Mac" scheme="http://jamiepoet.github.io/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>基于XMPP实现即时通讯（三、增删好友、好友列表、发送各种消息）</title>
    <link href="http://jamiepoet.github.io/2016/07/29/%E5%9F%BA%E4%BA%8EXMPP%E5%AE%9E%E7%8E%B0%E5%8D%B3%E6%97%B6%E9%80%9A%E8%AE%AF%EF%BC%88%E4%B8%89%E3%80%81%E5%A2%9E%E5%88%A0%E5%A5%BD%E5%8F%8B%E3%80%81%E5%A5%BD%E5%8F%8B%E5%88%97%E8%A1%A8%E3%80%81%E5%8F%91%E9%80%81%E5%90%84%E7%A7%8D%E6%B6%88%E6%81%AF%EF%BC%89/"/>
    <id>http://jamiepoet.github.io/2016/07/29/基于XMPP实现即时通讯（三、增删好友、好友列表、发送各种消息）/</id>
    <published>2016-07-29T08:57:59.000Z</published>
    <updated>2016-08-03T07:31:13.000Z</updated>
    
    <content type="html">&lt;p&gt;在实现整套流程时，引入了UI框架MessageDisplayKit和XHPopMenu，可以通过pod直接集成到工程中：&lt;code&gt;pod &amp;quot;MessageDisplayKit&amp;quot;, pod &amp;quot;XHPopMenu&amp;quot;&lt;/code&gt;&lt;br&gt;同时引入了腾讯云来存储多媒体消息，具体为腾讯云的对象存储服务： &lt;a href=&quot;https://www.qcloud.com/product/cos.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://www.qcloud.com/product/cos.html&lt;/a&gt; 。整个完整的Demo会在最后一节放到个人github上。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;一、增删好友&quot;&gt;&lt;a href=&quot;#一、增删好友&quot; class=&quot;headerlink&quot; title=&quot;一、增删好友&quot;&gt;&lt;/a&gt;一、增删好友&lt;/h2&gt;&lt;p&gt;首先了解一下XMPP的通信有三种方式：message、presence和iq，主要内容和区别可以看下：&lt;a href=&quot;http://my.oschina.net/greki/blog/272867，简单了解下。&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://my.oschina.net/greki/blog/272867，简单了解下。&lt;/a&gt;&lt;br&gt;然后需要知道好友相关请求使用的是presence, 它有以下几种type：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;available: 表示处于在线状态(通知好友在线)
unavailable: 表示处于离线状态（通知好友下线）
subscribe: 表示发出添加好友的申请（添加好友请求）
unsubscribe: 表示发出删除好友的申请（删除好友请求）
unsubscribed: 表示拒绝添加对方为好友（拒绝添加对方为好友）
error: 表示presence信息报中包含了一个错误消息。（出错）
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;1-添加好友&quot;&gt;&lt;a href=&quot;#1-添加好友&quot; class=&quot;headerlink&quot; title=&quot;1. 添加好友&quot;&gt;&lt;/a&gt;1. 添加好友&lt;/h3&gt;&lt;p&gt;先申请花名册并进行激活&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//花名册相关
var _xmppRoster: XMPPRoster!
var _xmppRosterStorage = XMPPRosterCoreDataStorage.sharedInstance()     //花名单存储
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在activeXMPPModules方法中激活模块：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//花名册
 _xmppRoster = XMPPRoster(rosterStorage: _xmppRosterStorage)
 //自动获取用户列表
 _xmppRoster.autoFetchRoster = true
 _xmppRoster.autoAcceptKnownPresenceSubscriptionRequests = true
 //激活&amp;amp;添加代理
 _xmppRoster.activate(_xmppStream)
 _xmppRoster.addDelegate(self, delegateQueue: dispatch_get_main_queue())

 //重连
 _xmppReconnect = XMPPReconnect()
 _xmppReconnect.activate(_xmppStream)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;功能实现：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
     添加好友

 - parameter userId:         好友id
 - parameter addFriendBlock: 添加好友请求的结果回调（并非好友回复的结果，只是请求是否发送成功的回调）
 */
func addFriend(friendId: String, addFriendBlock: LGXMPP_AddOrDeleteFriendRequestBlock?) {

    let friendJidString = self.getChatJidString(friendId)
    //先判断是不是添加了自己
    if friendJidString == &amp;quot;\(_userId!)@\(vHostChat)&amp;quot;{
        if addFriendBlock != nil{
            addFriendBlock!(isSuccess: false, faildMsg: &amp;quot;你不能添加你自己哦&amp;quot;)
            return
        }
    }

    // 先判断是否已经是我的好友，如果是，就不再添加
    let userJID = XMPPJID.jidWithString(friendJidString)
    if let theFirendData = _xmppRosterStorage.userForJID(userJID, xmppStream: _xmppStream, managedObjectContext: _xmppRosterStorage.mainThreadManagedObjectContext){
        if theFirendData.subscription == &amp;quot;to&amp;quot; || theFirendData.subscription == &amp;quot;both&amp;quot;{
            if addFriendBlock != nil{
                addFriendBlock!(isSuccess: false, faildMsg: &amp;quot;\(friendJidString)已经是你的好友了或者已发送过请求了哦&amp;quot;)
                return
            }
        }

    }
    _addFriendBlock = addFriendBlock
    _xmppRoster.subscribePresenceToUser(userJID)
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;2-删除好友&quot;&gt;&lt;a href=&quot;#2-删除好友&quot; class=&quot;headerlink&quot; title=&quot;2. 删除好友&quot;&gt;&lt;/a&gt;2. 删除好友&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;func deleteFriend(friendJid: XMPPJID, deleteFriendBlock: LGXMPP_AddOrDeleteFriendRequestBlock?) {
    _deleteFriendBlock = deleteFriendBlock
    _xmppRoster.removeUser(friendJid)
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;3-增删好友的相关回调&quot;&gt;&lt;a href=&quot;#3-增删好友的相关回调&quot; class=&quot;headerlink&quot; title=&quot;3. 增删好友的相关回调&quot;&gt;&lt;/a&gt;3. 增删好友的相关回调&lt;/h3&gt;&lt;p&gt; // MARK:  ——————————–  好友列表相关回调 ——————————-&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//获取到一个好友节点- 已经互为好友以后，会回调此方法
func xmppRoster(sender: XMPPRoster!, didReceiveRosterItem item: DDXMLElement!) {
    DPrintln(&amp;quot;11 item = \(item)&amp;quot;)
}

func xmppRosterDidEndPopulating(sender: XMPPRoster!) {
    DPrintln(&amp;quot;好友列表加载完毕&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在下面两个回调中响应好友申请请求及被删除的回调，可能会有人疑惑为何只有提示框和选择交互部分内容，没有数据库更新，UI更新通知等内容。这个是因为在下一节好友列表获取中，可以把好友列表搜索器设置成UI界面的代理，当好友列表有任何信息更新时，让UI界面的tableview.reloadData()即可，所以这两个方法只要让用户进行是否同意的选择及相关提示即可&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    func xmppRoster(sender: XMPPRoster!, didReceivePresenceSubscriptionRequest presence: XMPPPresence!) {
        DPrintln(&amp;quot;\(presence)&amp;quot;)

        // 好友在线状态
        let type = presence.type()
        let fromUser = presence.from().user
        let user = _xmppStream.myJID.user
        DPrintln(&amp;quot;接收到状态为：\(type),来自发送者\(fromUser),接收者\(user)&amp;quot;)

        // 防止自己添加自己为好友
        if fromUser != user{
            switch type {
            case &amp;quot;available&amp;quot;:
                DPrintln(&amp;quot;好友上线&amp;quot;)
            case &amp;quot;away&amp;quot;:
                DPrintln(&amp;quot;好友离开&amp;quot;)
            case &amp;quot;do not disturb&amp;quot;:
                DPrintln(&amp;quot;好友忙碌&amp;quot;)
            case &amp;quot;unavailable&amp;quot;:
                DPrintln(&amp;quot;好友下线&amp;quot;)
            case &amp;quot;subscribe&amp;quot;:
                DPrintln(&amp;quot;请求添加好友&amp;quot;)
                _addMeJid = presence.from()
                let alert = UIAlertView(title: &amp;quot;好友申请&amp;quot;, message: &amp;quot;\(fromUser)请求添加你为好友，是否同意?&amp;quot;, delegate: self, cancelButtonTitle: &amp;quot;取消&amp;quot;, otherButtonTitles: &amp;quot;确定&amp;quot;)
                alert.tag = vAddFriendAlertTag
                alert.show()
            case &amp;quot;unsubscribe&amp;quot;:
                DPrintln(&amp;quot;请求并删除了我这个好友&amp;quot;)
                case &amp;quot;unsubscribed&amp;quot;:
                DPrintln(&amp;quot;对方拒绝了我的好友请求&amp;quot;)
                case &amp;quot;error&amp;quot;:
                DPrintln(&amp;quot;错误信息&amp;quot;)
            default:
                DPrintln(&amp;quot;其它信息 type = \(type)&amp;quot;)
            }
        }
    }

    func xmppRoster(sender: XMPPRoster!, didReceiveRosterPush iq: XMPPIQ!) {

        let query = iq.elementForName(&amp;quot;query&amp;quot;).childAtIndex(0) as! DDXMLElement

        let jidString = query.attributeForName(&amp;quot;jid&amp;quot;).stringValue()
        let subscription = query.attributeForName(&amp;quot;subscription&amp;quot;).stringValue()
        if let ask = query.attributeForName(&amp;quot;ask&amp;quot;)
        {
            DPrintln(&amp;quot;请求类型 \(ask.stringValue())&amp;quot;)
            if _addFriendBlock != nil{
                _addFriendBlock!(isSuccess: true, faildMsg: nil)
                _addFriendBlock = nil
            }
            return
        }

        switch subscription {
        case &amp;quot;from&amp;quot;:
            DPrintln(&amp;quot;我已同意对方添加我为好友，关系确认成功&amp;quot;)
            //此处不用提示，因为同意对方后，就会双方都变成彼此的好友，会进入both，同时 from会回调两次,ask也会被调用两次（从from变成both）
//            Tools.shared.showAlertViewAndDismissDefault(&amp;quot;你已经成为\(jidString)的好友&amp;quot;, message: nil)

        case &amp;quot;to&amp;quot;:
            DPrintln(&amp;quot;添加对方为好友成功,或者被对方删除&amp;quot;)
            //此处不用提示，因为添加好友：默认对方同意后，就会双方都变成彼此的好友，会进入both，同时 to会回调两次
            //还有可能是被对方删除我这个好友的回调
//            Tools.shared.showAlertViewAndDismissDefault(&amp;quot;\(jidString)已经成为你的好友&amp;quot;, message: nil)
        case &amp;quot;both&amp;quot;:
            DPrintln(&amp;quot;添加好友成功，彼此成为好友&amp;quot;)
            //此处不用提示，因为默认对方同意后，就会双方都变成彼此的好友，会进入both，同时 to会回调两次
            Tools.shared.showAlertViewAndDismissDefault(&amp;quot;\(jidString)和你已经互为好友&amp;quot;, message: nil)

        case &amp;quot;remove&amp;quot;:
            DPrintln(&amp;quot;删除好友成功&amp;quot;)
            if _deleteFriendBlock != nil{
                //删除会调用两次,subscription会从 from(带ask) 变成 none(带ask)，最后是remove
                _deleteFriendBlock!(isSuccess: true, faildMsg: nil)
                _deleteFriendBlock = nil
            }

        default:
                DPrintln(&amp;quot;subscription = \(subscription)）&amp;quot;)
            }
}

  // MARK:  ---------------- UIAlertView delegate -----------------
    func alertView(alertView: UIAlertView, clickedButtonAtIndex buttonIndex: Int) {

        DPrintln(&amp;quot;check index = \(buttonIndex)&amp;quot;)
        if alertView.tag == vAddFriendAlertTag{
        if buttonIndex == 1{
            DPrintln(&amp;quot;同意添加好友&amp;quot;)
            _xmppRoster.acceptPresenceSubscriptionRequestFrom(_addMeJid!, andAddToRoster: true)
            _addMeJid = nil
        }else{
            Println(&amp;quot;拒接好友申请&amp;quot;)
            _xmppRoster.rejectPresenceSubscriptionRequestFrom(_addMeJid!)
            _addMeJid = nil
        }
    }
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;二、好友列表&quot;&gt;&lt;a href=&quot;#二、好友列表&quot; class=&quot;headerlink&quot; title=&quot;二、好友列表&quot;&gt;&lt;/a&gt;二、好友列表&lt;/h2&gt;&lt;p&gt;好友列表可以从服务器获取，也可以在本地XMPP默认数据库中获取（XMPPRosterCoreDataStorage.sharedInstance() 中），通常用后者实现，设置代理后可自动监听好友状态的更新&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//好友列表-//好友搜索结果控制器
       func getFriendList(sucessResult: (NSFetchedResultsController -&amp;gt; Void)?, faildMsg: (String? -&amp;gt; Void)?){

           if !_xmppStream.isAuthenticated()
           {
               if faildMsg != nil{
                   return faildMsg!(&amp;quot;请先登录哦&amp;quot;)
               }
           }

           let context = _xmppRosterStorage.mainThreadManagedObjectContext
           //从CoreData中获取数据
           //通过实体获取FetchRequest实体
           let request = NSFetchRequest(entityName: NSStringFromClass(XMPPUserCoreDataStorageObject))

   //        //添加排序规则
   //        let sortFriend = NSSortDescriptor(key: &amp;quot;jidStr&amp;quot;, ascending: true)
   //        request.sortDescriptors = [sortFriend]

           // 在线状态排序
           let sortOnLine = NSSortDescriptor(key: &amp;quot;sectionNum&amp;quot;, ascending: true)
           // 显示的名称排序
           let sortByName = NSSortDescriptor(key: &amp;quot;displayName&amp;quot;, ascending: true)

           // 添加排序
           request.sortDescriptors = [sortOnLine, sortByName]

           // 添加谓词过滤器 状态为None的排除（加好友对方还没确认，或者好友关系，被对方删除）
           request.predicate = NSPredicate(format: &amp;quot;!(subscription CONTAINS &amp;apos;none&amp;apos;)&amp;quot;)

           dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)) {

               //获取FRC
               let friendResultsController = NSFetchedResultsController(fetchRequest: request, managedObjectContext: context, sectionNameKeyPath: nil, cacheName: nil)
               do {
                   try friendResultsController.performFetch()
               } catch let error as NSError {

                   dispatch_async(dispatch_get_main_queue(), {
                       if faildMsg != nil{
                           return faildMsg!(error.description)
                       }
                   })
               }

               dispatch_async(dispatch_get_main_queue(), {
                   if sucessResult != nil{
                       return sucessResult!(friendResultsController)
                   }
               })
           }
       }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用时，将得到的friendResultsConrtoller.sections.count作为UI显示好友列表tableview的numberOfSectionsInTableView,sections对应位置的numberOfObjects为numberOfRowsInSection，friendResultsConrtoller?.objectAtIndexPath(indexPath) 可以得到一个XMPPUserCoreDataStorageObject对象，作为每个cell的UI数据源。&lt;br&gt;同时将friendResultsConrtoller的代理设置成这个好友列表的UIViewController，在其代理 方法controllerDidChangeContent实现self.tableView.reloadData()，即可针对数据库更新来更新UI。&lt;/p&gt;
&lt;h2 id=&quot;三、发送各种消息&quot;&gt;&lt;a href=&quot;#三、发送各种消息&quot; class=&quot;headerlink&quot; title=&quot;三、发送各种消息&quot;&gt;&lt;/a&gt;三、发送各种消息&lt;/h2&gt;&lt;h3 id=&quot;1-发送&quot;&gt;&lt;a href=&quot;#1-发送&quot; class=&quot;headerlink&quot; title=&quot;1. 发送&quot;&gt;&lt;/a&gt;1. 发送&lt;/h3&gt;&lt;p&gt;在具体项目中实现发送文字以外的消息时（图片，视频，语音等），通常还是采用文字消息的xml方式来通过XMPP传递，只是增加自已约定的属性来区分真正的消息类型，多媒体消息通常会先上传到服务器，发送时传递给对方具体URL和相关属性即可；&lt;br&gt;表情的发送也可以走文字xml格式，只是标记真正类型为表情，同时传递的内容是表情名称或URL地址，接受方解析完成后直接将工程或网络中的表情显示出来即可。&lt;br&gt;下面看具体Demo方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
     发送消息(文字，图片，视频，语音等所有格式),包括单独聊天和群聊

     - parameter messageType:      消息类型，来自MessageDisplayKit,也可以自己实现枚举
     - parameter messageURL:       多媒体消息时，传递的是URL
     - parameter messageText:      文字消息时的文字内容
     - parameter otherMessage:     其它附带属性
     - parameter receiveId:        发送对象的id，可能是某个人也可以是某个房间id
     - parameter isRoomChat:       是否是聊天室（房间）聊天
     - parameter sendMessageBlock: 发送成功后的回调（来确保消息已成功到达服务器）
     */
    func sendMessage(messageType: XHBubbleMessageMediaType, messageURL: String?, messageText: String?, otherMessage: String?, receiveId: String, isRoomChat: Bool,sendMessageBlock: LGXMPP_SendMessageBlock) {

        _sendMessageBlock = nil
        _sendMessageBlock = sendMessageBlock

        let bodyElement = DDXMLElement(name: &amp;quot;body&amp;quot;)
        if messageType == .Text{
            bodyElement.setStringValue(messageText)
        }else {
            bodyElement.setStringValue(messageURL)
        }

        let messageElement = DDXMLElement(name: &amp;quot;message&amp;quot;)
        messageElement.addAttributeWithName(&amp;quot;type&amp;quot;, stringValue: isRoomChat ? &amp;quot;groupchat&amp;quot; : &amp;quot;chat&amp;quot;)
        messageElement.addAttributeWithName(&amp;quot;releayType&amp;quot;, stringValue: self.getMessageTypeString(messageType))
        if otherMessage != nil{
            messageElement.addAttributeWithName(&amp;quot;otherMessage&amp;quot;, stringValue: otherMessage!)
        }

        let recevieJidString = self.getChatJidString(receiveId)
        messageElement.addAttributeWithName(&amp;quot;to&amp;quot;, stringValue: recevieJidString)
        messageElement.addChild(bodyElement)
        _xmppStream.sendElement(messageElement)
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;对应的getMessageTypeString方法是将枚举转换成可传递的string,接受者收到这个string后通过getMessageTypeFromString来还原成对应的type&lt;/p&gt;
&lt;h3 id=&quot;2-发送回调&quot;&gt;&lt;a href=&quot;#2-发送回调&quot; class=&quot;headerlink&quot; title=&quot;2. 发送回调&quot;&gt;&lt;/a&gt;2. 发送回调&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;// MARK:  --------------------------------  发送消息-回调  -------------------------------
   //message是一种基本推送消息方法，它不要求响应。主要用于IM、groupChat、alert和notification之类的应用中。
   func xmppStream(sender: XMPPStream!, didSendMessage message: XMPPMessage!) {
       DPrintln(&amp;quot;发送成功&amp;quot;)
       if _sendMessageBlock != nil{
           _sendMessageBlock!(isSucess: true, faildMsg: nil)
       }
   }

   func xmppStream(sender: XMPPStream!, didFailToSendMessage message: XMPPMessage!, error: NSError!) {
       Tools.shared.showAlertViewAndDismissDefault(nil, message: &amp;quot;消息发送失败&amp;quot;)
       if _sendMessageBlock != nil{
           _sendMessageBlock!(isSucess: false, faildMsg: error.description)
       }
   }
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;3-接收多种消息类型&quot;&gt;&lt;a href=&quot;#3-接收多种消息类型&quot; class=&quot;headerlink&quot; title=&quot;3. 接收多种消息类型&quot;&gt;&lt;/a&gt;3. 接收多种消息类型&lt;/h3&gt;&lt;p&gt; 结合发送消息复用文字（”chat”）类型的实现方式，接收消息也要对应进行解析，其中getXHMessageFromXMPPMessage方法可以解析当前收到的消息，也可以解析从数据库中得到的历史记录消息。&lt;br&gt;关于已读和未读，本地设备可以再建一个记录消息数据库，标记已读未读红点等，同时在后台实现本地推送；服务器端需要建立离线消息推送机制；如果涉及到多设备的同步就更复杂了，本Demo不讨论已读状态的实现&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// MARK:  --------------------------------  接收消息-来自XMPP回调  -------------------------------
   func xmppStream(sender: XMPPStream!, didReceiveMessage message: XMPPMessage!) {
       DPrintln(&amp;quot;收到消息 \(message)&amp;quot;)

       if message.isChatMessageWithBody(){

           let newMessage = self.getXHMessageFromXMPPMessage(message, messageSender: message.from().full(), isUserSendMessage: false, isHistory: false)
           //用通知的方式来触发聊天界面刷新相关UI
           NSNotificationCenter.defaultCenter().postNotificationName(kXMPPNewMessage, object: newMessage, userInfo: nil)
       }
       else{
           DPrintln(&amp;quot;收到其它类型消息/非正常消息&amp;quot;)
           //在这里可以判断是否是消息回执，对消息回执作处理，可参考：http://blog.csdn.net/huwenfeng_2011/article/details/43459039
           //消息回执说明文档 http://xmpp.org/extensions/xep-0184.html
       }
   }

   /**
    将XMPPMessage转成和UI可对应的XHMessage,(XHMessage来自MessageDisplayKit,也可以实现自己的UI模型)

    - parameter message:           收到的消息
    - parameter messageSender:     消息发送者
    - parameter isUserSendMessage: 是否是我自己发送的消息
    - parameter isHistory:         是否是历史记录

    - returns: 返回XHMessage
    */
   func getXHMessageFromXMPPMessage(message: XMPPMessage, messageSender: String?, isUserSendMessage: Bool, isHistory: Bool) -&amp;gt; XHMessage {

       var sender = messageSender
       if sender == nil{
           //发送者为空，判定为自己发出去的信息
          sender = &amp;quot;\(_userId!)@\(vHostChat)&amp;quot;
       }
       let nowTime = NSDate()
       let mediaText = message.body()

       var newMessage: XHMessage
       var messageType = XHBubbleMessageMediaType.Text
       if let releayType = message.attributeForName(&amp;quot;releayType&amp;quot;){
           messageType = self.getMessageTypeFromString(releayType.stringValue())
       }

       switch messageType {
       case .Emotion:
           newMessage = XHMessage(emotionPath: NSBundle.mainBundle().pathForResource(mediaText, ofType: nil), sender: sender, timestamp: nowTime)
       case .LocalPosition:
           newMessage = XHMessage(text: &amp;quot;发送了位置信息&amp;quot;, sender: sender, timestamp: nowTime)
       case .Photo:
           newMessage = XHMessage(photo: nil, thumbnailUrl: mediaText, originPhotoUrl: nil, sender: sender, timestamp: nowTime)
       case .Text:
           newMessage = XHMessage(text: mediaText, sender: sender, timestamp: nowTime)
       case .Video:
           newMessage = XHMessage(videoConverPhoto: nil, videoPath: nil, videoUrl: mediaText, sender: sender, timestamp: nowTime)
       case .Voice:
           var durantion = &amp;quot;60&amp;quot;
           if let durantionMessage = message.attributeForName(&amp;quot;otherMessage&amp;quot;){
               durantion = durantionMessage.stringValue()
           }

           newMessage = XHMessage(voicePath: nil, voiceUrl: mediaText, voiceDuration: durantion, sender: sender, timestamp: nowTime)
           //当前收到的消息，通过腾讯云来下载语音（可以放到UI界面来实现）
           //历史记录复用此方法时，通过查询Url来得到可能已存在本地的voicepath
           let resultPath = LGTXCloudManager.shared.getFilePathFromURLString(mediaText, typeString: &amp;quot;file&amp;quot;)
           if NSFileManager.defaultManager().fileExistsAtPath(resultPath){
               newMessage.voicePath = resultPath
           }

       }
       DPrintln(&amp;quot;sender = \(sender)&amp;quot;)
       if isUserSendMessage {
           newMessage.bubbleMessageType = .Sending         //发送消息
       }else{
           newMessage.bubbleMessageType = .Receiving       //接收消息
       }
       //未读已读推送等需定制化实现，这里简单将历史信息全部标记成已读
       newMessage.isRead = isHistory
       return newMessage
   }
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;p&gt;作者 &lt;a href=&quot;http://jamiepoet.github.io&quot;&gt;@代码书生&lt;/a&gt;&lt;br&gt;2016 年 07月 29日    &lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;在实现整套流程时，引入了UI框架MessageDisplayKit和XHPopMenu，可以通过pod直接集成到工程中：&lt;code&gt;pod &amp;quot;MessageDisplayKit&amp;quot;, pod &amp;quot;XHPopMenu&amp;quot;&lt;/code&gt;&lt;br&gt;同时引入了腾讯云来存储多媒体消息，具体为腾讯云的对象存储服务： &lt;a href=&quot;https://www.qcloud.com/product/cos.html&quot;&gt;https://www.qcloud.com/product/cos.html&lt;/a&gt; 。整个完整的Demo会在最后一节放到个人github上。&lt;br&gt;
    
    </summary>
    
      <category term="即时通讯（IM）" scheme="http://jamiepoet.github.io/categories/%E5%8D%B3%E6%97%B6%E9%80%9A%E8%AE%AF%EF%BC%88IM%EF%BC%89/"/>
    
    
      <category term="XMPP" scheme="http://jamiepoet.github.io/tags/XMPP/"/>
    
      <category term="IM" scheme="http://jamiepoet.github.io/tags/IM/"/>
    
      <category term="iOS" scheme="http://jamiepoet.github.io/tags/iOS/"/>
    
      <category term="Mac" scheme="http://jamiepoet.github.io/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>基于XMPP实现即时通讯（二、登陆、上下线、接收消息）</title>
    <link href="http://jamiepoet.github.io/2016/06/17/%E5%9F%BA%E4%BA%8EXMPP%E5%AE%9E%E7%8E%B0%E5%8D%B3%E6%97%B6%E9%80%9A%E8%AE%AF%EF%BC%88%E4%BA%8C%E3%80%81%E7%99%BB%E9%99%86%E3%80%81%E4%B8%8A%E4%B8%8B%E7%BA%BF%E3%80%81%E6%8E%A5%E6%94%B6%E6%B6%88%E6%81%AF%EF%BC%89/"/>
    <id>http://jamiepoet.github.io/2016/06/17/基于XMPP实现即时通讯（二、登陆、上下线、接收消息）/</id>
    <published>2016-06-17T01:47:57.000Z</published>
    <updated>2016-08-03T09:06:00.000Z</updated>
    
    <content type="html">&lt;p&gt;关于XMPP 本地环境搭建、登录、好友列表，好友状态、发送接收多媒体消息、增删好友、群聊等功能点，大家可以跟我一起来学习，最后章节会将整个完整Demo放到我的github。&lt;br&gt;因为很早就开始用swift来做项目，所以本文以swift进行示例。Xcode版本为7.3.1。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;一、了解XMPP常用对象&quot;&gt;&lt;a href=&quot;#一、了解XMPP常用对象&quot; class=&quot;headerlink&quot; title=&quot;一、了解XMPP常用对象&quot;&gt;&lt;/a&gt;一、了解XMPP常用对象&lt;/h2&gt;&lt;p&gt;XMPPStream：xmpp基础服务类&lt;br&gt;XMPPRoster：好友列表类&lt;br&gt;XMPPRosterCoreDataStorage：好友列表（用户账号）在core data中的操作类&lt;br&gt;XMPPvCardCoreDataStorage：好友名片（昵称，签名，性别，年龄等信息）在core data中的操作类&lt;br&gt;XMPPvCardTemp：好友名片实体类，从数据库里取出来的都是它&lt;br&gt;xmppvCardAvatarModule：好友头像&lt;br&gt;XMPPReconnect：如果失去链接,自动重连&lt;br&gt;XMPPRoom：提供多用户聊天支持&lt;br&gt;XMPPPubSub：发布订阅&lt;/p&gt;
&lt;h2 id=&quot;二、引入头文件&quot;&gt;&lt;a href=&quot;#二、引入头文件&quot; class=&quot;headerlink&quot; title=&quot;二、引入头文件&quot;&gt;&lt;/a&gt;二、引入头文件&lt;/h2&gt;&lt;p&gt;根据&lt;a href=&quot;http://jamiepoet.github.io/2016/06/16/基于XMPP实现即时通讯（一、环境搭建）/#四、工程中集成XMPP&quot;&gt;基于XMPP实现即时通讯（一、环境搭建）&lt;/a&gt;的集成方式，cocapods引入的XMPP为OC版本，所以要在工程的桥接文件中引入基础服务类：&lt;code&gt;#import “XMPP.h&amp;quot;&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;三、登陆&quot;&gt;&lt;a href=&quot;#三、登陆&quot; class=&quot;headerlink&quot; title=&quot;三、登陆&quot;&gt;&lt;/a&gt;三、登陆&lt;/h2&gt;&lt;p&gt;登陆之前我们得先在openfire上建个用户（也可以直接用管理员帐号），然后再进行以下步骤：初始化核心类、建立socket链接、链接成功后通过密码进行身份校验、更新上线状态。&lt;/p&gt;
&lt;h3 id=&quot;1-新建用户&quot;&gt;&lt;a href=&quot;#1-新建用户&quot; class=&quot;headerlink&quot; title=&quot;1. 新建用户&quot;&gt;&lt;/a&gt;1. 新建用户&lt;/h3&gt;&lt;p&gt;用管理员帐号登录openfire,在用户/组中新建用户。（实际业务流程中，此建立过程也是后台服务器实现，只是需要客户端传递相关注册信息）&lt;/p&gt;
&lt;h3 id=&quot;2-初始化基础类&quot;&gt;&lt;a href=&quot;#2-初始化基础类&quot; class=&quot;headerlink&quot; title=&quot;2. 初始化基础类&quot;&gt;&lt;/a&gt;2. 初始化基础类&lt;/h3&gt;&lt;p&gt;可以新建一个XMPPManager类，以下方法均在此类实现。（用来管理所有XMPP核心业务服务）：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;func xmppInit()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    _xmppStream = XMPPStream()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    _xmppStream?.addDelegate(self, delegateQueue: dispatch_get_main_queue())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;3-建立socket链接&quot;&gt;&lt;a href=&quot;#3-建立socket链接&quot; class=&quot;headerlink&quot; title=&quot;3. 建立socket链接&quot;&gt;&lt;/a&gt;3. 建立socket链接&lt;/h3&gt;&lt;p&gt;3.1 先在文件头申明常量：&lt;br&gt;因为是在个人MAC搭建Openfire服务器调试，所以此hostname为个人MAC共享访问地址，在mac的系统偏好设置-&amp;gt;共享里可以查看到完整地址，在实际调试过程中，真机登录必须用此host,但聊天可能为localhost,也可能为此host，模拟器也存在同样的情况，当消息发送不成功时，可以尝试修改这些host&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;let vHostName = &amp;quot;JamieiMac.local&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;3.2 建立socket链接：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;func xmppConnect(userId: String, password: String) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    let userName = &amp;quot;\(userId)@\(vHostName)&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    let jid = XMPPJID.jidWithString(userName)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    _xmppStream.myJID = jid&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    _xmppStream.hostName = vHostName&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    _pwd = password&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    do &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        try _xmppStream.connectWithTimeout(10)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; catch let error &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        DPrintln(&amp;quot;发送链接请求失败 \(error),请检查网络或服务器配置&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; // MARK:  --------------------------------  链接回调  -------------------------------&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;func xmppStream(sender: XMPPStream!, socketDidConnect socket: GCDAsyncSocket!) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    DPrintln(&amp;quot;建立socket链接&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;func xmppStreamDidConnect(sender: XMPPStream!) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    DPrintln(&amp;quot;链接成功&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //进行身份校验&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    self.authenticateUser()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;func xmppStreamConnectDidTimeout(sender: XMPPStream!)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    DPrintln(&amp;quot;链接超时&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Tools.shared.showAlertViewAndDismissDefault(nil, message: &amp;quot;链接超时，请重试&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;3.3 校验身份&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;func authenticateUser() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if _xmppStream.isAuthenticated()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    do &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        try _xmppStream.authenticateWithPassword(_pwd)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; catch let error &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Tools.dissmissLoadingInWindow()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        DPrintln(&amp;quot;发送验证请求失败 \(error)&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        _xmppStream.disconnect()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// MARK:  --------------------------------  身份验证回调  -------------------------------&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;func xmppStreamDidAuthenticate(sender: XMPPStream!)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        DPrintln(&amp;quot;身份验证成功&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//        Tools.shared.showAlertViewAndDismissDefault(nil, message: &amp;quot;登录成功!&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.onLine()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Tools.dissmissLoadingInWindow()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        NSNotificationCenter.defaultCenter().postNotificationName(&amp;quot;loginSuccess&amp;quot;, object: nil, userInfo: nil)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;func xmppStream(sender: XMPPStream!, didNotAuthenticate error: DDXMLElement!) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    DPrintln(&amp;quot;身份验证失败&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Tools.dissmissLoadingInWindow()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        NSNotificationCenter.defaultCenter().postNotificationName(&amp;quot;loginError&amp;quot;, object: nil, userInfo: nil)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         _xmppStream.disconnect()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;四、上下线&quot;&gt;&lt;a href=&quot;#四、上下线&quot; class=&quot;headerlink&quot; title=&quot;四、上下线&quot;&gt;&lt;/a&gt;四、上下线&lt;/h2&gt;&lt;p&gt;用户默认状态有：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;available 上线&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;away 离开&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;do not disturb 忙碌&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;unavailable 下线&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;默认身份验证成功后，用户还是灰色（下线状态）的，因此通常登陆成功后直接发送上线状态。上线成功后在openfire的用户摘要中可看到在线状态变绿。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;func onLine()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    DPrintln(&amp;quot;发送上线状态&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    let presence = XMPPPresence(type: &amp;quot;available&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    _xmppStream.sendElement(presence)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//用户主动下线(同时断开链接)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;func outLine()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    DPrintln(&amp;quot;发送下线状态&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    let presence = XMPPPresence(type: &amp;quot;unavailable&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    _xmppStream.sendElement(presence)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //断开链接&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    _xmppStream.disconnect()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;五、接收信息&quot;&gt;&lt;a href=&quot;#五、接收信息&quot; class=&quot;headerlink&quot; title=&quot;五、接收信息&quot;&gt;&lt;/a&gt;五、接收信息&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;当接收到&amp;lt; message /&amp;gt; 标签时，XMPP会回调didReceiveMessage的方法。根据 XMPP 协议，消息体的内容存储在标签 &amp;lt; body /&amp;gt; 内&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;  func xmppStream(sender: XMPPStream!, didReceiveMessage message: XMPPMessage!) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        DPrintln(&amp;quot;收到消息 \(message)&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        //stringValue默认解析body内字符&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        let messageString = message.stringValue()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if !NSString.isNilOrEmpty(messageString)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            let messageBody = message.elementForName(&amp;quot;body&amp;quot;).stringValue&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            let fromeUser = (message.attributeForName(&amp;quot;from&amp;quot;)).stringValue&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            UIView.showAlertView(fromeUser(), andMessage: messageBody())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; else&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            DPrintln(&amp;quot;收到其它类型消息/非正常消息&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;测试接收消息: 登录及上线成功后，在openfire控制界面中，打开“会话”-》“工具”，即可向所有用户发送消息，赶紧验证下你的代码吧！&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;p&gt;作者 &lt;a href=&quot;http://jamiepoet.github.io&quot;&gt;@代码书生&lt;/a&gt;&lt;br&gt;2016 年 06月 16日    &lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;关于XMPP 本地环境搭建、登录、好友列表，好友状态、发送接收多媒体消息、增删好友、群聊等功能点，大家可以跟我一起来学习，最后章节会将整个完整Demo放到我的github。&lt;br&gt;因为很早就开始用swift来做项目，所以本文以swift进行示例。Xcode版本为7.3.1。&lt;br&gt;
    
    </summary>
    
      <category term="即时通讯（IM）" scheme="http://jamiepoet.github.io/categories/%E5%8D%B3%E6%97%B6%E9%80%9A%E8%AE%AF%EF%BC%88IM%EF%BC%89/"/>
    
    
      <category term="XMPP" scheme="http://jamiepoet.github.io/tags/XMPP/"/>
    
      <category term="IM" scheme="http://jamiepoet.github.io/tags/IM/"/>
    
      <category term="iOS" scheme="http://jamiepoet.github.io/tags/iOS/"/>
    
      <category term="Mac" scheme="http://jamiepoet.github.io/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>基于XMPP实现即时通讯（一、环境搭建）</title>
    <link href="http://jamiepoet.github.io/2016/06/16/%E5%9F%BA%E4%BA%8EXMPP%E5%AE%9E%E7%8E%B0%E5%8D%B3%E6%97%B6%E9%80%9A%E8%AE%AF%EF%BC%88%E4%B8%80%E3%80%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%EF%BC%89/"/>
    <id>http://jamiepoet.github.io/2016/06/16/基于XMPP实现即时通讯（一、环境搭建）/</id>
    <published>2016-06-16T06:49:56.000Z</published>
    <updated>2016-08-03T09:05:01.000Z</updated>
    
    <content type="html">&lt;p&gt;关于XMPP 本地环境搭建、登录、好友列表，好友状态、发送接收多媒体消息、增删好友、群聊等功能点，大家可以跟我一起来学习, 最后章节会将整个完整Demo放到我的github。&lt;br&gt;因为很早就开始用swift来做项目，所以本文以swift进行示例。Xcode版本为7.3.1。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;一、IM协议及服务器选型&quot;&gt;&lt;a href=&quot;#一、IM协议及服务器选型&quot; class=&quot;headerlink&quot; title=&quot;一、IM协议及服务器选型&quot;&gt;&lt;/a&gt;一、IM协议及服务器选型&lt;/h2&gt;&lt;p&gt;参考&lt;br&gt;&lt;a href=&quot;http://liudanking.me/arch/xmpp%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%80%89%E5%9E%8B/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://liudanking.me/arch/xmpp%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%80%89%E5%9E%8B/&lt;/a&gt;&lt;br&gt;协议选型：XMPP已经成为标准的IM协议。XMPP官网：&lt;a href=&quot;http://XMPP.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://XMPP.org/&lt;/a&gt;&lt;br&gt;服务器型：使用广泛的是ejabberd，jabberd 2.x， Openfire，Tigase。从编程语言角度来看主要是JAVA和Erlang。JAVA语言的优势是类库完备，容易招人。Erlang的优势是hot code swap，live console， 高并发。而且ejabberd是对XMPP协议支持最好、实现最为全面的server。因此企业在不考虑独立开发服务器的情况下，初期选型基本建议采用ejabberd。&lt;/p&gt;
&lt;p&gt;本文我们主要实践iOS端流程，不考虑太多服务器实现，因为Openfire易安装，插件功能丰富，我们使用Openfire&lt;/p&gt;
&lt;h2 id=&quot;二、MAC上搭建MySQL&quot;&gt;&lt;a href=&quot;#二、MAC上搭建MySQL&quot; class=&quot;headerlink&quot; title=&quot;二、MAC上搭建MySQL&quot;&gt;&lt;/a&gt;二、MAC上搭建MySQL&lt;/h2&gt;&lt;p&gt;因为服务器需要数据库支撑，所以我们在搭建Openfire前要先搭建数据库。参照: &lt;a href=&quot;http://www.cnblogs.com/xiaodao/archive/2013/04/04/2999426.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.cnblogs.com/xiaodao/archive/2013/04/04/2999426.html&lt;/a&gt; ,总结如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;安装：在 MySQL官网上 &lt;a href=&quot;http://dev.mysql.com/downloads/mysql/，下载MySQL，安装最新dmg版本&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://dev.mysql.com/downloads/mysql/，下载MySQL，安装最新dmg版本&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;运行：在系统偏好设置最下面一栏找到MySQL图标，点击图标后，点击Start MysAL Server 按钮，启动MySQL&lt;/li&gt;
&lt;li&gt;配置：输入alias命令 &lt;code&gt;alias mysql=/usr/local/mysql/bin/mysql&lt;/code&gt; 回车，再输入&lt;code&gt;alias mysqladmin=/usr/local/mysql/bin/mysqladmin&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;设置MySQL root帐号的密码: &lt;code&gt;mysqladmin -u root password 初始密码&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;连接数据库: &lt;code&gt;mysql -u root -p&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;创建Openfire数据库: &lt;code&gt;create database openfire&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;三、MAC上搭建Openfire&quot;&gt;&lt;a href=&quot;#三、MAC上搭建Openfire&quot; class=&quot;headerlink&quot; title=&quot;三、MAC上搭建Openfire&quot;&gt;&lt;/a&gt;三、MAC上搭建Openfire&lt;/h2&gt;&lt;p&gt;参照 &lt;a href=&quot;http://www.cnblogs.com/xiaodao/archive/2013/04/05/3000554.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.cnblogs.com/xiaodao/archive/2013/04/05/3000554.html&lt;/a&gt; 只需要执行到通过 admin登陆管理控制台即可。（不必通过数据库修改默认admin账户，可能会导致无法登录的情况，要修改可通过控制台进行新增或修改）&lt;/p&gt;
&lt;h2 id=&quot;四、工程中集成XMPP&quot;&gt;&lt;a href=&quot;#四、工程中集成XMPP&quot; class=&quot;headerlink&quot; title=&quot;四、工程中集成XMPP&quot;&gt;&lt;/a&gt;四、工程中集成XMPP&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;XMPP的git地址为： &lt;a href=&quot;https://github.com/robbiehanson/XMPPFramework&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/robbiehanson/XMPPFramework&lt;/a&gt; 。其中有较详细文档&lt;/li&gt;
&lt;li&gt;集成至Xcode: 最简单的方法，通过CocoaPods集成: &lt;code&gt;pod “XMPPFramework”&lt;/code&gt;。强烈推荐没有用过CocoaPods的同学使用这个第三方库管理工具。&lt;br&gt;CocoaPods详解之——使用篇：&lt;br&gt;&lt;a href=&quot;http://blog.csdn.net/wzzvictory/article/details/18737437&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/wzzvictory/article/details/18737437&lt;/a&gt;&lt;br&gt;（其中 &lt;a href=&quot;http://ruby.taobao.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://ruby.taobao.org/&lt;/a&gt;  这个源地址应该要更新成 &lt;a href=&quot;https://ruby.taobao.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://ruby.taobao.org/&lt;/a&gt;  ）&lt;/li&gt;
&lt;li&gt;如果cocoapods提示 target overrides the ENABLE_BITCODE build setting defined等信息，可以在build settings中将 Enable Bitcode 的选项中添加other内空：&lt;code&gt;$(inherited)&lt;/code&gt;。此时选项显示为 &lt;code&gt;No-$(inherited)&lt;/code&gt; 。再重新运行pods命令即可解决&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;p&gt;作者 &lt;a href=&quot;http://jamiepoet.github.io&quot;&gt;@代码书生&lt;/a&gt;&lt;br&gt;2016 年 06月 16日    &lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;关于XMPP 本地环境搭建、登录、好友列表，好友状态、发送接收多媒体消息、增删好友、群聊等功能点，大家可以跟我一起来学习, 最后章节会将整个完整Demo放到我的github。&lt;br&gt;因为很早就开始用swift来做项目，所以本文以swift进行示例。Xcode版本为7.3.1。&lt;/p&gt;
    
    </summary>
    
      <category term="即时通讯（IM）" scheme="http://jamiepoet.github.io/categories/%E5%8D%B3%E6%97%B6%E9%80%9A%E8%AE%AF%EF%BC%88IM%EF%BC%89/"/>
    
    
      <category term="XMPP" scheme="http://jamiepoet.github.io/tags/XMPP/"/>
    
      <category term="IM" scheme="http://jamiepoet.github.io/tags/IM/"/>
    
      <category term="iOS" scheme="http://jamiepoet.github.io/tags/iOS/"/>
    
      <category term="Mac" scheme="http://jamiepoet.github.io/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>FFmpeg学习笔记(二、集成x264)</title>
    <link href="http://jamiepoet.github.io/2016/06/07/FFmpeg%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C%E3%80%81%E9%9B%86%E6%88%90x264/"/>
    <id>http://jamiepoet.github.io/2016/06/07/FFmpeg学习笔记-二、集成x264/</id>
    <published>2016-06-07T03:30:11.000Z</published>
    <updated>2016-06-07T03:32:14.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;一、x264源码包下载&quot;&gt;&lt;a href=&quot;#一、x264源码包下载&quot; class=&quot;headerlink&quot; title=&quot;一、x264源码包下载&quot;&gt;&lt;/a&gt;一、x264源码包下载&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;从&lt;a href=&quot;http://www.videolan.org/developers/x264.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.videolan.org/developers/x264.html&lt;/a&gt; 下载得到最新的x264源码包，解压后得到一个名为x264-snapshot-xxx的文件夹&lt;/li&gt;
&lt;li&gt;为了后续脚本编译，将上面的x264-snapshot-xxx文件夹重命名为x264&lt;/li&gt;
&lt;/ol&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;二、编译x264&quot;&gt;&lt;a href=&quot;#二、编译x264&quot; class=&quot;headerlink&quot; title=&quot;二、编译x264&quot;&gt;&lt;/a&gt;二、编译x264&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;从 &lt;a href=&quot;https://github.com/kewlbear/x264-ios&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/kewlbear/x264-ios&lt;/a&gt; 下载x264的编译脚本文件，将下载得到的build-x264.sh放到上面的x264文件夹同一级目录下。（.sh文件和x264文件夹同一层级）&lt;/li&gt;
&lt;li&gt;安装插件gas-preprocessor.pl，详见&lt;a href=&quot;http://jamiepoet.github.io/2016/06/01/FFmpeg%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80%E3%80%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/#2-%E5%AE%89%E8%A3%85%E6%8F%92%E4%BB%B6&quot;&gt;《FFmpeg学习笔记(一、环境搭建) 》的1.2安装插件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;cd至 .sh文件所在目录，在确保路径中无中文的情况下（有中文会在编译中提示找不到文件），运行脚本 &lt;code&gt;./build-x264.sh&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;脚本运行完毕后，会生成4个文件夹：x264-iOS，scratch-x264，thin-x264。查看x264-iOS中lib文件夹下的libx264.a。命令为： &lt;code&gt;lipo -info libx264.a&lt;/code&gt; 。一切顺利的话会提示 Architectures in the fat file，同时支持armv7、 armv7s、i386、x86_64、arm64所有格式&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;三、编译带x264的FFmpeg包&quot;&gt;&lt;a href=&quot;#三、编译带x264的FFmpeg包&quot; class=&quot;headerlink&quot; title=&quot;三、编译带x264的FFmpeg包&quot;&gt;&lt;/a&gt;三、编译带x264的FFmpeg包&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;拷贝x264-iOS文件夹至FFmpeg的编译脚本build-ffmpeg.sh所在目录下（.sh和x264-iOS文件夹同一层级），重命名x264-iOS为fat-x264&lt;/li&gt;
&lt;li&gt;打开build-ffmpeg.sh文件（Xcode或TextWrangler等脚本编辑器，文本编辑也可直接打开），找到 &lt;code&gt;X264=‘pwd’/fat-x264&lt;/code&gt; 这一行(搜索/fat-x264)，将其前面的“#”去掉。（去掉注释，让此行代码生效）&lt;/li&gt;
&lt;li&gt;CD到build-ffmpeg.sh文件所在目录，执行 &lt;code&gt;./build-FFmpeg.sh&lt;/code&gt;。编译时间较长，如果成功，将得到FFmpeg-iOS文件夹，会有7个.a文件。（比单纯的FFmpeg编译多出一个.a文件）&lt;/li&gt;
&lt;li&gt;如果编译过程中提示 /bin/sh: …: No such file or directory 等异常，可先CD到/usr/local/bin/目录下，直接调用build-ffmpeg.sh文件进行编译&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;四、工程配置&quot;&gt;&lt;a href=&quot;#四、工程配置&quot; class=&quot;headerlink&quot; title=&quot;四、工程配置&quot;&gt;&lt;/a&gt;四、工程配置&lt;/h2&gt;&lt;p&gt;参照&lt;a href=&quot;http://jamiepoet.github.io/2016/06/01/FFmpeg%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80%E3%80%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/#4-%E5%B7%A5%E7%A8%8B%E9%85%8D%E7%BD%AE&quot;&gt;《FFmpeg学习笔记(一、环境搭建) 》的4.工程配置&lt;/a&gt;，只是多了一个.a文件，全部添加至工程即可。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;作者 &lt;a href=&quot;http://jamiepoet.github.io&quot;&gt;@代码书生&lt;/a&gt;&lt;br&gt;2016 年 06月 07日    &lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、x264源码包下载&quot;&gt;&lt;a href=&quot;#一、x264源码包下载&quot; class=&quot;headerlink&quot; title=&quot;一、x264源码包下载&quot;&gt;&lt;/a&gt;一、x264源码包下载&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;从&lt;a href=&quot;http://www.videolan.org/developers/x264.html&quot;&gt;http://www.videolan.org/developers/x264.html&lt;/a&gt; 下载得到最新的x264源码包，解压后得到一个名为x264-snapshot-xxx的文件夹&lt;/li&gt;
&lt;li&gt;为了后续脚本编译，将上面的x264-snapshot-xxx文件夹重命名为x264&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="视频直播/点播" scheme="http://jamiepoet.github.io/categories/%E8%A7%86%E9%A2%91%E7%9B%B4%E6%92%AD-%E7%82%B9%E6%92%AD/"/>
    
    
      <category term="iOS" scheme="http://jamiepoet.github.io/tags/iOS/"/>
    
      <category term="Mac" scheme="http://jamiepoet.github.io/tags/Mac/"/>
    
      <category term="FFmpeg" scheme="http://jamiepoet.github.io/tags/FFmpeg/"/>
    
      <category term="x264" scheme="http://jamiepoet.github.io/tags/x264/"/>
    
  </entry>
  
  <entry>
    <title>搭建自己的Hexo博客（Mac环境）</title>
    <link href="http://jamiepoet.github.io/2016/06/06/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84Hexo%E5%8D%9A%E5%AE%A2%EF%BC%88Mac%E7%8E%AF%E5%A2%83%EF%BC%89/"/>
    <id>http://jamiepoet.github.io/2016/06/06/搭建自己的Hexo博客（Mac环境）/</id>
    <published>2016-06-06T02:49:28.000Z</published>
    <updated>2016-06-15T16:00:00.000Z</updated>
    
    <content type="html">&lt;p&gt;相关的博客很多，碰到的问题应该都可以找到答案，所以只对环境搭建及建站做了详细描述，一起学习，有问题在评论中交流哈。&lt;br&gt;hexo中文文档： &lt;a href=&quot;https://hexo.io/zh-cn/docs/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://hexo.io/zh-cn/docs/&lt;/a&gt;&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;一、环境搭建&quot;&gt;&lt;a href=&quot;#一、环境搭建&quot; class=&quot;headerlink&quot; title=&quot;一、环境搭建&quot;&gt;&lt;/a&gt;一、环境搭建&lt;/h2&gt;&lt;h3 id=&quot;1-安装git&quot;&gt;&lt;a href=&quot;#1-安装git&quot; class=&quot;headerlink&quot; title=&quot;1. 安装git&quot;&gt;&lt;/a&gt;1. 安装git&lt;/h3&gt;&lt;p&gt;1.1 安装ruby: &lt;code&gt;ruby -e &amp;quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)”&lt;/code&gt;&lt;br&gt;1.2 通过ruby安装git: &lt;code&gt;brew install git&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;2-安装Node&quot;&gt;&lt;a href=&quot;#2-安装Node&quot; class=&quot;headerlink&quot; title=&quot;2. 安装Node&quot;&gt;&lt;/a&gt;2. 安装Node&lt;/h3&gt;&lt;p&gt;在 &lt;a href=&quot;https://nodejs.org/en/download/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://nodejs.org/en/download/&lt;/a&gt; 下载pkg安装包进行安装&lt;/p&gt;
&lt;h3 id=&quot;3-安装Hexo&quot;&gt;&lt;a href=&quot;#3-安装Hexo&quot; class=&quot;headerlink&quot; title=&quot;3. 安装Hexo&quot;&gt;&lt;/a&gt;3. 安装Hexo&lt;/h3&gt;&lt;p&gt;运行：&lt;code&gt;npm install -g hexo-cli&lt;/code&gt;&lt;br&gt;如果提示npm ERR!…/Users/jamie/npm-debug.log等ERR，就运行条4步&lt;/p&gt;
&lt;h3 id=&quot;4-安装nvm，通过nvm来安装hexo&quot;&gt;&lt;a href=&quot;#4-安装nvm，通过nvm来安装hexo&quot; class=&quot;headerlink&quot; title=&quot;4. 安装nvm，通过nvm来安装hexo&quot;&gt;&lt;/a&gt;4. 安装nvm，通过nvm来安装hexo&lt;/h3&gt;&lt;p&gt;4.1 根据 &lt;a href=&quot;https://github.com/creationix/nvm&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/creationix/nvm&lt;/a&gt; 说明&lt;br&gt;运行&lt;code&gt;curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.31.1/install.sh | bash&lt;/code&gt;&lt;br&gt;成功后，重启终端，如果运行nvm -h提示not found，可先运行&lt;code&gt;touch ~/.bash_profile&lt;/code&gt;。再重新执行上面的curl脚本。&lt;br&gt;4.2 运行  &lt;code&gt;nvm install 4&lt;/code&gt; 安装node(nvm是安装Node的最佳方式)&lt;br&gt;4.3 运行 &lt;code&gt;npm install -g hexo-cli&lt;/code&gt; 安装hexo&lt;/p&gt;
&lt;h2 id=&quot;二、建站&quot;&gt;&lt;a href=&quot;#二、建站&quot; class=&quot;headerlink&quot; title=&quot;二、建站&quot;&gt;&lt;/a&gt;二、建站&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;创建博客文件夹，cd到此文件夹路径&lt;/li&gt;
&lt;li&gt;执行命令： &lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;nam init
nam install
hexo generate
hexo server
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;完成后，在浏览器输入 &lt;a href=&quot;http://0.0.0.0:4000/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://0.0.0.0:4000/&lt;/a&gt; 就可以预览博客。相关配置及写文章可查看 &lt;a href=&quot;https://hexo.io/zh-cn/docs/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://hexo.io/zh-cn/docs/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;三、写文章碰到的问题&quot;&gt;&lt;a href=&quot;#三、写文章碰到的问题&quot; class=&quot;headerlink&quot; title=&quot;三、写文章碰到的问题&quot;&gt;&lt;/a&gt;三、写文章碰到的问题&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;修改_config.yml文件时，冒号后面必须有一个空格（半角），否则修改后重新hexo server会报错can not read a block mapping entry…&lt;/li&gt;
&lt;li&gt;new了文章后重新开启服务时报错Cannot read property ‘offset’ of null，可能是时区配置错误，可以将时区配置成Asia&lt;/li&gt;
&lt;li&gt;写文章时要遵循markdown语法，推荐编辑器： &lt;a href=&quot;https://www.zybuluo.com/cmd/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://www.zybuluo.com/cmd/&lt;/a&gt; 。编辑好后再拷贝至.md文件&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;四、模板&quot;&gt;&lt;a href=&quot;#四、模板&quot; class=&quot;headerlink&quot; title=&quot;四、模板&quot;&gt;&lt;/a&gt;四、模板&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.zhihu.com/question/24422335&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://www.zhihu.com/question/24422335&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;五、访问数统计、文章阅读数、多说评论、友情链接、打赏、其它配置等&quot;&gt;&lt;a href=&quot;#五、访问数统计、文章阅读数、多说评论、友情链接、打赏、其它配置等&quot; class=&quot;headerlink&quot; title=&quot;五、访问数统计、文章阅读数、多说评论、友情链接、打赏、其它配置等&quot;&gt;&lt;/a&gt;五、访问数统计、文章阅读数、多说评论、友情链接、打赏、其它配置等&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://theme-next.iissnan.com/theme-settings.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://theme-next.iissnan.com/theme-settings.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;六、将博客部署至Gighub&quot;&gt;&lt;a href=&quot;#六、将博客部署至Gighub&quot; class=&quot;headerlink&quot; title=&quot;六、将博客部署至Gighub&quot;&gt;&lt;/a&gt;六、将博客部署至Gighub&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://jingyan.baidu.com/article/d8072ac47aca0fec95cefd2d.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://jingyan.baidu.com/article/d8072ac47aca0fec95cefd2d.html&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;作者 &lt;a href=&quot;http://jamiepoet.github.io&quot;&gt;@代码书生&lt;/a&gt;&lt;br&gt;2016 年 06月 06日    &lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;相关的博客很多，碰到的问题应该都可以找到答案，所以只对环境搭建及建站做了详细描述，一起学习，有问题在评论中交流哈。&lt;br&gt;hexo中文文档： &lt;a href=&quot;https://hexo.io/zh-cn/docs/&quot;&gt;https://hexo.io/zh-cn/docs/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="博客" scheme="http://jamiepoet.github.io/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="Mac" scheme="http://jamiepoet.github.io/tags/Mac/"/>
    
      <category term="博客" scheme="http://jamiepoet.github.io/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>主流视频直播参数总结</title>
    <link href="http://jamiepoet.github.io/2016/06/02/%E4%B8%BB%E6%B5%81%E8%A7%86%E9%A2%91%E7%9B%B4%E6%92%AD%E5%8F%82%E6%95%B0%E6%80%BB%E7%BB%93/"/>
    <id>http://jamiepoet.github.io/2016/06/02/主流视频直播参数总结/</id>
    <published>2016-06-02T07:43:42.000Z</published>
    <updated>2016-06-07T02:12:53.000Z</updated>
    
    <content type="html">&lt;p&gt;新手在学习视频直播前，肯定和我一样，有太多疑惑，不知从何入手，个人觉得需要先对整体平台有个大概的认识，然后再结合自己专业一步步学习研究，整体框架如图：&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;&lt;img src=&quot;/2016/06/02/主流视频直播参数总结/直播框架.png&quot; alt=&quot;通用直播模型&quot; title=&quot;通用直播模型&quot;&gt;&lt;/p&gt;
&lt;p&gt;然后在网上查阅了不少资料，也和行业内一个朋友进行了交流，对主流平台参数总结如下（不对或不全面的地方欢迎大家指点）：&lt;/p&gt;
&lt;h3 id=&quot;1-收流（主流参数）&quot;&gt;&lt;a href=&quot;#1-收流（主流参数）&quot; class=&quot;headerlink&quot; title=&quot;1. 收流（主流参数）&quot;&gt;&lt;/a&gt;1. 收流（主流参数）&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:left&quot;&gt;平台&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;协议&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;封装格式&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;视频编码&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;音频编码&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;解码技术&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;播放器&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;PC端&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;RTMP&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;FLV&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;H.264&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;AAC&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;Flash播放器无插件直接播放&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;Flash播放器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;App&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;RTMP/HLS(苹果)&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;FLV&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;H.264&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;AAC&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;FFMPEG&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;ijkplayer等&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&quot;2-推流（主流参数）&quot;&gt;&lt;a href=&quot;#2-推流（主流参数）&quot; class=&quot;headerlink&quot; title=&quot;2. 推流（主流参数）&quot;&gt;&lt;/a&gt;2. 推流（主流参数）&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:left&quot;&gt;平台&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;采集&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;前处理（美颜等）&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;视频编码&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;音频编码&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;封装格式&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;推流协议&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;PC端（已逐步放弃）&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;OBS&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;美颜摄像头+OBS插件&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;H.264&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;AAC&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;FLV(服务器封装)&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;RTMP&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;App&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;FFMPEG+x264&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;GPUImage&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;H.264&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;AAC&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;FLV(服务器封装)&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;RTMP&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&quot;3-服务器（主流框架）&quot;&gt;&lt;a href=&quot;#3-服务器（主流框架）&quot; class=&quot;headerlink&quot; title=&quot;3. 服务器（主流框架）&quot;&gt;&lt;/a&gt;3. 服务器（主流框架）&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;传输&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;架构&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;截图/水印/转码/鉴黄等&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;CDN服务商&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;ossrs&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;定制开发+运维等&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&quot;4-参考资料&quot;&gt;&lt;a href=&quot;#4-参考资料&quot; class=&quot;headerlink&quot; title=&quot;4. 参考资料&quot;&gt;&lt;/a&gt;4. 参考资料&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;循序渐进的学习FFMPEG（0基础学习音视频相关技术）&lt;br&gt;&lt;a href=&quot;http://blog.csdn.net/leixiaohua1020/article/details/15811977&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/leixiaohua1020/article/details/15811977&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;如何搭建一个完整的视频直播系统？&lt;a href=&quot;http://www.zhihu.com/question/42162310&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.zhihu.com/question/42162310&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;技术实现难度 &lt;a href=&quot;http://www.zhihu.com/question/41868659&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.zhihu.com/question/41868659&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;常用SDK推荐 &lt;a href=&quot;http://www.zhihu.com/question/37183046&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.zhihu.com/question/37183046&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;作者 &lt;a href=&quot;http://jamiepoet.github.io&quot;&gt;@代码书生&lt;/a&gt;&lt;br&gt;2016 年 06月 02日    &lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;新手在学习视频直播前，肯定和我一样，有太多疑惑，不知从何入手，个人觉得需要先对整体平台有个大概的认识，然后再结合自己专业一步步学习研究，整体框架如图：&lt;br&gt;
    
    </summary>
    
      <category term="视频直播/点播" scheme="http://jamiepoet.github.io/categories/%E8%A7%86%E9%A2%91%E7%9B%B4%E6%92%AD-%E7%82%B9%E6%92%AD/"/>
    
    
      <category term="iOS" scheme="http://jamiepoet.github.io/tags/iOS/"/>
    
      <category term="Mac" scheme="http://jamiepoet.github.io/tags/Mac/"/>
    
      <category term="FFmpeg" scheme="http://jamiepoet.github.io/tags/FFmpeg/"/>
    
  </entry>
  
  <entry>
    <title>FFmpeg学习笔记(一、环境搭建)</title>
    <link href="http://jamiepoet.github.io/2016/06/01/FFmpeg%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80%E3%80%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>http://jamiepoet.github.io/2016/06/01/FFmpeg学习笔记-一、环境搭建/</id>
    <published>2016-06-01T09:44:43.000Z</published>
    <updated>2016-06-06T08:35:25.000Z</updated>
    
    <content type="html">&lt;!-- ![FFmpeg-logo](http://p5.qhimg.com/t0124cf926ea9205e45.jpg) --&gt;
&lt;p&gt;从今天开始大家一起来学习FFmpeg吧，目标是移动端 录制-&amp;gt;编码-&amp;gt;推流，收流-&amp;gt;解码-&amp;gt;播放整套流程。&lt;/p&gt;
&lt;hr&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;一、Mac上安装及体验&quot;&gt;&lt;a href=&quot;#一、Mac上安装及体验&quot; class=&quot;headerlink&quot; title=&quot;一、Mac上安装及体验&quot;&gt;&lt;/a&gt;一、Mac上安装及体验&lt;/h2&gt;&lt;h3 id=&quot;1-安装FFmpeg&quot;&gt;&lt;a href=&quot;#1-安装FFmpeg&quot; class=&quot;headerlink&quot; title=&quot;1. 安装FFmpeg&quot;&gt;&lt;/a&gt;1. 安装FFmpeg&lt;/h3&gt;&lt;p&gt;终端运行：&lt;code&gt;brew install ffmpeg&lt;/code&gt;&lt;br&gt;如果提示liblzma.5.dylib版本不够，运行命令：&lt;code&gt;brew install xz&lt;/code&gt; （因为通过&lt;code&gt;brew search liblzma&lt;/code&gt; 提示lzma已经是xz的一部分）&lt;/p&gt;
&lt;h3 id=&quot;2-功能体验&quot;&gt;&lt;a href=&quot;#2-功能体验&quot; class=&quot;headerlink&quot; title=&quot;2. 功能体验&quot;&gt;&lt;/a&gt;2. 功能体验&lt;/h3&gt;&lt;p&gt;找到一个mp4格式的文件，在终端运行：&lt;code&gt;ffmpeg -i demo.mp4 output.avi&lt;/code&gt;&lt;br&gt;成功后，既可播放转换完成的AVI视频。（如果Mac默认的播放器无法播放，可安装Movist播放）&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;二、iOS环境搭建&quot;&gt;&lt;a href=&quot;#二、iOS环境搭建&quot; class=&quot;headerlink&quot; title=&quot;二、iOS环境搭建&quot;&gt;&lt;/a&gt;二、iOS环境搭建&lt;/h2&gt;&lt;h3 id=&quot;1-安装-yams&quot;&gt;&lt;a href=&quot;#1-安装-yams&quot; class=&quot;headerlink&quot; title=&quot;1. 安装 yams&quot;&gt;&lt;/a&gt;1. 安装 yams&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;brew install yams
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;2-安装插件&quot;&gt;&lt;a href=&quot;#2-安装插件&quot; class=&quot;headerlink&quot; title=&quot;2. 安装插件&quot;&gt;&lt;/a&gt;2. 安装插件&lt;/h3&gt;&lt;p&gt;2.1 从 &lt;a href=&quot;https://github.com/libav/gas-preprocessor&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/libav/gas-preprocessor&lt;/a&gt; 下载文件脚本文件&lt;br&gt;2.2 将下载得到的 gas-preprocessor.pl 拷贝至bin目录下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;`cp gas-preprocessor.pl /usr/local/bin/`
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2.3 修改此文件权限：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cd /usr/local/bin
sudo chmod 777 gas-preprocessor.pl
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;3-通过脚本完成编译&quot;&gt;&lt;a href=&quot;#3-通过脚本完成编译&quot; class=&quot;headerlink&quot; title=&quot;3. 通过脚本完成编译&quot;&gt;&lt;/a&gt;3. 通过脚本完成编译&lt;/h3&gt;&lt;p&gt;从 &lt;a href=&quot;https://github.com/kewlbear/FFmpeg-iOS-build-script&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/kewlbear/FFmpeg-iOS-build-script&lt;/a&gt; 下载得到build-ffmpeg.sh文件 执行此文件，得到FFmpeg-iOS文件夹，里面包括两个子文件夹，分别包括头文件及.a文件&lt;br&gt;(如果编译提示/bin/sh: …: No such file or directory等异常，可先CD到/usr/local/bin/目录下，直接调用build-ffmpeg.sh文件进行编译)&lt;/p&gt;
&lt;h3 id=&quot;4-工程配置&quot;&gt;&lt;a href=&quot;#4-工程配置&quot; class=&quot;headerlink&quot; title=&quot;4. 工程配置&quot;&gt;&lt;/a&gt;4. 工程配置&lt;/h3&gt;&lt;p&gt;4.1 将FFmpeg-iOS文件夹添加至Xcode工程，确保“Library Search Paths”指向正确的FFmpeg-iOS/lib文件夹(通常添加至工程时会自动生成正确指向);确保“Header Search Paths”指向正确的FFmpeg-iOS/include文件夹（通常需手动设置）&lt;br&gt;4.2 确保项目添加了以下framework：libz.dylib、libbz2.dylib、libiconv.dylib、avfoundation、coremedia以及VideoToolbox&lt;br&gt;4.3 添加一个头文件引用 #include “avformat.h”，添加一个api语句：&lt;code&gt;av_register_all()&lt;/code&gt;&lt;br&gt;4.4 添加或修改一个类文件.m后缀改为.mm，开启混编模式。（swift混编模式中此步可省略）&lt;br&gt;4.5 运行工程，如果没有报错，则表示编译成功。恭喜，环境搭建完成了。（如果确保以上步骤正常，但编译时还是提示 ‘libavcodec/avcodec.h’ file not found，需修改“Header Search Paths”中FFmpeg-iOS/include文件夹的路径为绝对路径）&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;作者 &lt;a href=&quot;http://jamiepoet.github.io&quot;&gt;@代码书生&lt;/a&gt;&lt;br&gt;2016 年 06月 01日    &lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;!-- ![FFmpeg-logo](http://p5.qhimg.com/t0124cf926ea9205e45.jpg) --&gt;
&lt;p&gt;从今天开始大家一起来学习FFmpeg吧，目标是移动端 录制-&amp;gt;编码-&amp;gt;推流，收流-&amp;gt;解码-&amp;gt;播放整套流程。&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="视频直播/点播" scheme="http://jamiepoet.github.io/categories/%E8%A7%86%E9%A2%91%E7%9B%B4%E6%92%AD-%E7%82%B9%E6%92%AD/"/>
    
    
      <category term="iOS" scheme="http://jamiepoet.github.io/tags/iOS/"/>
    
      <category term="Mac" scheme="http://jamiepoet.github.io/tags/Mac/"/>
    
      <category term="FFmpeg" scheme="http://jamiepoet.github.io/tags/FFmpeg/"/>
    
  </entry>
  
</feed>
